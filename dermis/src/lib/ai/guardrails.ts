/**
 * AI Guardrails for Clinical Documentation
 *
 * These functions ensure AI-generated clinical content is safe, compliant,
 * and never makes definitive diagnostic claims without provider oversight.
 */

// Official disclaimer that must appear on all AI-generated content
export const AI_DISCLAIMER = `⚠️ AI-ASSISTED DOCUMENTATION - REQUIRES PROVIDER REVIEW AND APPROVAL

This content was generated by AI to assist with documentation. The provider must:
- Review all information for accuracy
- Verify all diagnoses and treatment recommendations
- Confirm appropriate coding before submission
- Add or modify any information as clinically indicated

AI suggestions are not clinical diagnoses and do not replace provider judgment.`

// Problematic diagnostic language patterns that need to be replaced
const DIAGNOSTIC_REPLACEMENTS: [RegExp, string][] = [
  [/\b(patient has|diagnosis is|diagnosed with|confirms?)\b/gi, 'findings consistent with'],
  [/\bthis is\b/gi, 'appearance suggestive of'],
  [/\bclearly shows?|definitely|certainly\b/gi, 'appears to show'],
  [/\bmalignant|melanoma\b(?! mentioned| suspected| considered)/gi, 'lesion requiring further evaluation'],
  [/\brecommend (starting|prescribing|using)\b/gi, 'provider may consider'],
  [/\bshould (take|use|apply)\b/gi, 'per provider discretion'],
  [/\bpatient will (take|use|start)\b/gi, 'provider may prescribe'],
]

// Absolute terms that should be hedged
const ABSOLUTE_TERMS = [
  /\balways\b/gi,
  /\bnever\b/gi,
  /\bcertainly\b/gi,
  /\bdefinitely\b/gi,
  /\bguaranteed?\b/gi,
  /\bclearly\b/gi,
  /\bobviously\b/gi,
]

// Terms that indicate fabricated information
const FABRICATION_INDICATORS = [
  /\bpatient reports.*(?:denies|confirms).*(?:denies|confirms)/gi, // Too many details
  /\bfamily history of.*in (mother|father|sibling).*diagnosed at age \d+/gi, // Specific details not provided
]

export interface ValidationResult {
  isValid: boolean
  warnings: string[]
  errors: string[]
  modifiedText?: string
}

export interface InputValidationResult {
  isValid: boolean
  error?: string
  warnings?: string[]
}

/**
 * Validates user input before sending to AI
 */
export function validateClinicalInput(
  quickInput: string,
  chiefComplaint?: string
): InputValidationResult {
  const errors: string[] = []
  const warnings: string[] = []

  // Check minimum input length - relaxed from 10 to allow brief but meaningful input
  if (!quickInput || quickInput.trim().length < 5) {
    errors.push(
      'Provider input is too brief. Please provide at least a few words describing the visit.'
    )
  }

  // Require chief complaint - but don't be too strict
  if (!chiefComplaint || chiefComplaint.trim().length < 2) {
    warnings.push(
      'Chief complaint is missing. Consider adding for complete documentation.'
    )
  }

  // Check for requests for diagnosis without examination - but this is less critical now
  const diagnosisRequestPatterns = [
    /what (is|could) (this|it) be/i,
    /diagnose/i,
  ]

  const hasExamFindings = /exam|examination|inspection|palpation|observed|noted|seen|found/i.test(quickInput)
  const requestsDiagnosis = diagnosisRequestPatterns.some(p => p.test(quickInput))

  if (requestsDiagnosis && !hasExamFindings) {
    warnings.push(
      'Input requests diagnosis. AI will provide clinical considerations based on available information.'
    )
  }

  return {
    isValid: errors.length === 0,
    error: errors.length > 0 ? errors.join(' ') : undefined,
    warnings: warnings.length > 0 ? warnings : undefined,
  }
}

/**
 * Validates and sanitizes AI-generated clinical note output
 */
export function validateClinicalOutput(noteText: string): ValidationResult {
  const warnings: string[] = []
  const errors: string[] = []
  let modifiedText = noteText

  // Check for absolute diagnostic language
  for (const [pattern, replacement] of DIAGNOSTIC_REPLACEMENTS) {
    if (pattern.test(modifiedText)) {
      warnings.push(
        `Replaced absolute diagnostic language with hedged terminology: "${pattern.source}"`
      )
      modifiedText = modifiedText.replace(pattern, replacement)
    }
  }

  // Check for absolute terms
  for (const pattern of ABSOLUTE_TERMS) {
    if (pattern.test(modifiedText)) {
      warnings.push(
        `Note contains absolute language that may need review: "${pattern.source}"`
      )
    }
  }

  // Check for potential fabrications
  for (const pattern of FABRICATION_INDICATORS) {
    if (pattern.test(modifiedText)) {
      errors.push(
        'Note appears to contain specific details not likely provided in input. Review for fabricated information.'
      )
    }
  }

  // Check for medication dosages without explicit mention
  const dosagePattern = /\b\d+\s*(mg|mcg|ml|units?)\b/gi
  const hasDosages = dosagePattern.test(modifiedText)
  if (hasDosages) {
    warnings.push(
      'Note includes medication dosages. Verify these were explicitly provided by the provider.'
    )
  }

  // Ensure hedging language is present in assessment
  const assessmentMatch = modifiedText.match(/ASSESSMENT:([\s\S]*?)(?=PLAN:|$)/i)
  if (assessmentMatch) {
    const assessment = assessmentMatch[1]
    const hasHedging = /consistent with|suggestive of|consider|differential|may represent/i.test(assessment)

    if (!hasHedging) {
      warnings.push(
        'Assessment section lacks hedging language. Consider adding "consistent with" or "differential includes".'
      )
    }
  }

  return {
    isValid: errors.length === 0,
    warnings,
    errors,
    modifiedText,
  }
}

/**
 * Validates code suggestions to ensure they're appropriately caveated
 */
export function validateCodeSuggestions(suggestions: {
  icd10?: Array<{ code: string; description: string }>
  cpt?: Array<{ code: string; description: string; units?: number }>
  differentials?: string[]
}): ValidationResult {
  const warnings: string[] = []
  const errors: string[] = []

  // Check for overly specific ICD-10 codes without appropriate caveats
  if (suggestions.icd10 && suggestions.icd10.length > 0) {
    const hasUnspecifiedCode = suggestions.icd10.some(code =>
      code.code.includes('.9') || code.description.toLowerCase().includes('unspecified')
    )

    if (!hasUnspecifiedCode && suggestions.icd10.length === 1) {
      warnings.push(
        'Only one specific ICD-10 code suggested. Consider whether an unspecified code or differential is more appropriate.'
      )
    }
  }

  // Check for procedure codes without clear documentation support
  if (suggestions.cpt && suggestions.cpt.length > 0) {
    warnings.push(
      'CPT codes suggested. Ensure each code is supported by documented procedure details (lesion location, size, method, etc.).'
    )
  }

  return {
    isValid: errors.length === 0,
    warnings,
    errors,
  }
}

/**
 * Sanitizes lesion/photo analysis output to avoid diagnostic claims
 */
export function sanitizeLesionAnalysis(analysisText: string): string {
  let sanitized = analysisText

  // Replace diagnostic terms with descriptive language
  const lesionReplacements: [RegExp, string][] = [
    [/\b(this|appears to be|is) (a )?melanoma\b/gi, 'features that warrant further evaluation'],
    [/\b(this|appears to be|is) (a )?basal cell carcinoma\b/gi, 'appearance concerning for malignancy'],
    [/\b(this|appears to be|is) (a )?squamous cell carcinoma\b/gi, 'features requiring biopsy'],
    [/\bmalignant\b/gi, 'atypical features present'],
    [/\bbenign\b/gi, 'appears consistent with benign process'],
    [/\b(needs?|requires?|should have)\b/gi, 'may benefit from'],
  ]

  for (const [pattern, replacement] of lesionReplacements) {
    sanitized = sanitized.replace(pattern, replacement)
  }

  // Ensure disclaimer is present
  if (!sanitized.includes('clinical correlation')) {
    sanitized += '\n\nNote: This analysis describes visible characteristics only and is not diagnostic. Clinical correlation, dermoscopic examination, and biopsy as indicated are recommended.'
  }

  return sanitized
}

/**
 * Adds required disclaimers and markers to AI-generated content
 */
export function addDisclaimersAndMarkers(content: {
  subjective?: string
  objective?: string
  assessment?: string
  plan?: string
  fullNote?: string
}): typeof content {
  const marked = { ...content }

  // Only add [INCOMPLETE] markers if sections are truly empty or extremely brief
  // Don't mark every short section - providers gave brief input intentionally
  if (marked.subjective && marked.subjective.trim().length < 10) {
    marked.subjective += '\n\n[INCOMPLETE - PROVIDER TO COMPLETE HISTORY]'
  }

  if (marked.objective && marked.objective.trim().length < 10) {
    marked.objective += '\n\n[INCOMPLETE - PROVIDER TO COMPLETE EXAMINATION]'
  }

  // Don't add verification markers to assessment if it already uses hedging language
  // The system prompt now requires hedging language, so this is redundant

  // Only mark treatments in plan that are clearly AI suggestions (not expansions of provider statements)
  // Look for phrases like "consider", "may benefit from" which indicate suggestions
  if (marked.plan) {
    // Only mark clear AI suggestions, not every treatment mention
    marked.plan = marked.plan.replace(
      /(provider may consider|consider|may benefit from) ([^.]+\.(topical|oral|systemic)[^.]+\.)/gi,
      '[SUGGESTED FOR PROVIDER CONSIDERATION] $1 $2'
    )
  }

  // Add disclaimer to full note
  if (marked.fullNote) {
    marked.fullNote = `${AI_DISCLAIMER}\n\n${'='.repeat(80)}\n\n${marked.fullNote}`
  }

  return marked
}

/**
 * Comprehensive validation pipeline for clinical note generation
 */
export function validateClinicalNoteGeneration(
  input: {
    quickInput: string
    chiefComplaint?: string
  },
  output: {
    subjective: string
    objective: string
    assessment: string
    plan: string
    fullNote: string
    suggestions: {
      icd10?: Array<{ code: string; description: string }>
      cpt?: Array<{ code: string; description: string; units?: number }>
      differentials?: string[]
    }
  }
): {
  isValid: boolean
  validatedOutput: typeof output
  warnings: string[]
  errors: string[]
} {
  const allWarnings: string[] = []
  const allErrors: string[] = []

  // Validate input
  const inputValidation = validateClinicalInput(input.quickInput, input.chiefComplaint)
  if (!inputValidation.isValid) {
    allErrors.push(inputValidation.error || 'Invalid input')
  }
  if (inputValidation.warnings) {
    allWarnings.push(...inputValidation.warnings)
  }

  // Validate output text
  const outputValidation = validateClinicalOutput(output.fullNote)
  if (outputValidation.warnings) {
    allWarnings.push(...outputValidation.warnings)
  }
  if (outputValidation.errors) {
    allErrors.push(...outputValidation.errors)
  }

  // Validate code suggestions
  const codeValidation = validateCodeSuggestions(output.suggestions)
  if (codeValidation.warnings) {
    allWarnings.push(...codeValidation.warnings)
  }
  if (codeValidation.errors) {
    allErrors.push(...codeValidation.errors)
  }

  // Apply sanitization
  const sanitizedOutput = {
    ...output,
    subjective: outputValidation.modifiedText?.match(/SUBJECTIVE:([\s\S]*?)(?=OBJECTIVE:|$)/i)?.[1].trim() || output.subjective,
    objective: outputValidation.modifiedText?.match(/OBJECTIVE:([\s\S]*?)(?=ASSESSMENT:|$)/i)?.[1].trim() || output.objective,
    assessment: outputValidation.modifiedText?.match(/ASSESSMENT:([\s\S]*?)(?=PLAN:|$)/i)?.[1].trim() || output.assessment,
    plan: outputValidation.modifiedText?.match(/PLAN:([\s\S]*?)$/i)?.[1].trim() || output.plan,
    fullNote: outputValidation.modifiedText || output.fullNote,
    suggestions: output.suggestions
  }

  // Add disclaimers and markers
  const finalOutput = addDisclaimersAndMarkers(sanitizedOutput)

  return {
    isValid: allErrors.length === 0,
    validatedOutput: finalOutput as typeof output,
    warnings: allWarnings,
    errors: allErrors,
  }
}
